<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grails | Lauri Piispanen]]></title>
  <link href="http://lauripiispanen.github.com/blog/categories/grails/atom.xml" rel="self"/>
  <link href="http://lauripiispanen.github.com/"/>
  <updated>2012-06-11T22:38:24+03:00</updated>
  <id>http://lauripiispanen.github.com/</id>
  <author>
    <name><![CDATA[Lauri Piispanen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Packing up: Moving Our Grails Plugins From SVN to Git]]></title>
    <link href="http://lauripiispanen.github.com/blog/2012/05/28/packing-up-moving-our-grails-plugins-from-svn-to-git/"/>
    <updated>2012-05-28T16:35:00+03:00</updated>
    <id>http://lauripiispanen.github.com/blog/2012/05/28/packing-up-moving-our-grails-plugins-from-svn-to-git</id>
    <content type="html"><![CDATA[<p>As part of the migration from SVN over to Git in our company, we also need to transport our internal Grails plugins to the new repo structure. These plugins have been developed since Grails 1.1.x, and as such, there's a thing or two that have changed over the years - in terms of how grails plugins are stored in a repo and how the published artifacts are resolved.</p>

<!--more-->


<p>When our internal plugin development process started, we were still using Grails 1.1. Grails plugins were a wonderful way for us to encapsulate functionality, so that we didn't have to reinvent the wheel with every new customer project.</p>

<p>Grails 1.1 relied heavily on SVN, whereas starting from 1.2 versions of Grails, migration towards <a href="http://ant.apache.org/ivy/">Apache Ivy</a> dependency resolution began to take place. Back then, the <em>right way</em> to publish plugins was to store them in an SVN repository as .zip files. While this feels "unclean" to how I see repos should be used, it was supported out of the box in Grails, and the process of using it was rather straightforward, so we stuck with it.</p>

<p>Fast-forward over to Grails 2.x, and the <em>correct</em> way to handle plugins is to set up an Ivy/Maven compliant repository and publish the .zip artefacts there. In fact, the old way of having the .zip artefacts in SVN is <a href="http://jira.grails.org/browse/GPRELEASE-36">no longer</a> supported at all.</p>

<p>So, to move over to Git, we would need to do two things:</p>

<ol>
<li>Use <em>git svn</em> to init the new repo and fetch the changes</li>
<li>Create an authors file to link committers across repositories</li>
<li>We need to get rid of the .zip files in our new git repo and move them to <a href="http://www.jfrog.com/products.php">Artifactory</a> instead</li>
</ol>


<p>To do this, we would use three commands:</p>

<pre><code>$ git svn init --no-minimize-url [SVN-repo]
</code></pre>

<p>The init command sets up a new git repo in an empty local dir, and <em>svn init</em> adds the appropriate remote refs to Git. Our SVN repo was laid out so that each plugin was in a subfolder in the repo root, and that subfolder followed the standard trunk/tags/branches layout, so I added <em>--no-minimize-url</em> flag to ensure that git svn considered the provided url the root of the repo, and would not attempt to navigate down towards the actual repo root.</p>

<pre><code>$ git svn fetch --authors-file=[authors-file]
</code></pre>

<p>Then I did an svn fetch for the remote refs, providing an authors file so that committers could be mapped correctly to Git. And authors file is a simple text file with each line corresponding to a different author:</p>

<pre><code>lpiispanen = Lauri Piispanen &lt;lauri.piispanen@my-email-address-is-gone.com&gt;
jdoe = John Doe &lt;john.doe@my-email-address-is-gone.com&gt;
</code></pre>

<p>Finally, I wanted to get rid of all the published artefacts in the SVN dirs, and <em>filter-branch</em> allowed me to do just that. An additional benefit of <em>filter-branch</em> is that it shrinks down the entire repo size - as if the artefacts had never been committed in the first place. You probably would not want to do this on an existing repo, since then the clones that people have already taken will face some nasty history conflicts - but as we're working on a brand new Git repo, it's fine:</p>

<pre><code>$ git filter-branch --index-filter 'git rm --cached --ignore-unmatch grails-*.zip' HEAD
</code></pre>

<p>That's it! We now have a clean git repo, ready to be pushed to a different remote. Now, the next step is to push the .zip artefacts to Artefactory and we can archive the SVN repo entirely.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Groovy primitive type cast gotcha when upgrading to Grails 2.0]]></title>
    <link href="http://lauripiispanen.github.com/blog/2012/02/23/groovy-primitive-type-cast-gotcha-when-upgrading-to-grails-2-dot-0/"/>
    <updated>2012-02-23T18:13:00+02:00</updated>
    <id>http://lauripiispanen.github.com/blog/2012/02/23/groovy-primitive-type-cast-gotcha-when-upgrading-to-grails-2-dot-0</id>
    <content type="html"><![CDATA[<p>When upgrading our Grails applications from 1.3.x to 2.0, I got burned by this slight change of semantics in Groovy 1.8.x:</p>

<p>Groovy 1.7.9:</p>

<p><code>java
groovy:000&gt; null as int
===&gt; null
</code></p>

<p>Groovy 1.8.0:</p>

<p><code>java
groovy:000&gt; null as float         
ERROR org.codehaus.groovy.runtime.typehandling.GroovyCastException:
Cannot cast object 'null' with class 'null' to class 'float'. Try 'java.lang.Float' instead
</code></p>

<p>Turns out this can bite you in quite many places. A very common pattern occurring in our taglibs was to cast attributes, even if they were optional. Like this:</p>

<p>``` java
def myTag = { attrs, body -></p>

<pre><code>def height = attrs.remove("height") as int
</code></pre>

<p>}
```</p>

<p>Which would've simply assigned <em>null</em> to <em>height</em> in Grails 1.3.x. Luckily you can just change your casts to boxed versions of the primitives (i.e. <em>as Integer</em>, <em>as Long</em> etc) and be done with it.</p>

<p>``` java
def myTag = { attrs, body -></p>

<pre><code>def height = attrs.remove("height") as Integer
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a backend for backbone.js Todos example with Grails and MongoDB]]></title>
    <link href="http://lauripiispanen.github.com/blog/2012/01/31/building-a-backend-for-backbone-dot-js-todos-example-with-grails-and-mongodb/"/>
    <updated>2012-01-31T18:09:00+02:00</updated>
    <id>http://lauripiispanen.github.com/blog/2012/01/31/building-a-backend-for-backbone-dot-js-todos-example-with-grails-and-mongodb</id>
    <content type="html"><![CDATA[<p>In case you haven't yet tried it yet, <a href="http://documentcloud.github.com/backbone/">Backbone.js</a> is a wonderful little JavaScript MVC framework. Ditto for <a href="http://grails.org/">Grails</a>! And soon you'll see that they are a great match for each other - in this post, we'll build a backend for the Backbone.js ToDo example using Grails and MongoDB.</p>

<p>You can fork the completed example application <a href="https://github.com/lauripiispanen/grails-backbone-mongodb-example">here</a>.</p>

<!-- more -->


<p>First, let's create the Grails application and install mongodb plugin. We'll also uninstall the default hibernate plugin. I'll be using the new Grails 2.0 interactive console throughout this entry. First, edit <em>grails-app/conf/BuildConfig.groovy</em> and replace this line:</p>

<pre><code>runtime ":hibernate:$grailsVersion"
</code></pre>

<p>with this to install the Grails MongoDB plugin:</p>

<pre><code>runtime ":mongodb:latest.integration"
</code></pre>

<p>...and configure Grails to mount into root context in development mode. Add this to <em>grails-app/conf/Config.groovy</em>:</p>

<pre><code>grails.app.context = "/"
</code></pre>

<p>and run the app with <em>run-app</em>:</p>

<pre><code>$ grails
grails&gt; run-app
</code></pre>

<p>Next up, let's copy the .js, .css and .png files from the standard backbone.js todo example into our <em>/web-app/</em> folder, and overwrite our <em>grails-app/views/index.gsp</em> with <em>index.html</em> from the example app. At this point the index file will appear if you start the app, but none of the JavaScript code is working - it's pointing to <em>/test/vendor/</em> etc. We'll change the app to use the Grails 2.0 Static Resources plugin and its bundles. You should have the following files in place:</p>

<pre><code>web-app/backbone.js
web-app/underscore.js
web-app/todos.js
web-app/destroy.png
web-app/todos.css
</code></pre>

<p>First, we create the resources bundle for our app in <em>grails-app/conf/TodoResources.groovy</em>:</p>

<pre><code>modules = {
    todo {
        dependsOn 'jquery, underscore, backbone'

        resource url: '/todos.css'
        resource url: '/todos.js'
    }
    backbone {
        resource url: '/backbone.js'
    }
    underscore {
        resource url: '/underscore.js'
    }
}
</code></pre>

<p>And then we create a layout to include our bundle on the page. You can repurpose the existing <em>grails-app/views/layouts/main.gsp</em> to suit our needs.</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
        &lt;head&gt;
                &lt;title&gt;&lt;g:layoutTitle default="Grails"/&gt;&lt;/title&gt;
                &lt;g:layoutHead/&gt;
                &lt;r:layoutResources /&gt;
        &lt;/head&gt;
        &lt;body&gt;
                &lt;g:layoutBody/&gt;
                &lt;r:layoutResources /&gt;
        &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>And then we take the layout in use by removing all css links from <em>index.gsp</em> and replacing them with:</p>

<pre><code>&lt;r:require module="todo" /&gt;
&lt;meta name="layout" content="main"&gt;
</code></pre>

<p>At this point your todo application should <em>almost</em> work. It's complaining about the missing localstorage plugin, which is fine because we're about to replace it anyway. So just remove this line from <em>todos.js</em>:</p>

<pre><code>localStorage: new Store("todos"),
</code></pre>

<p>and replace it with:</p>

<pre><code>url: '/todos',
</code></pre>

<p>But now the todos app is complaining that it can't find that URL. Which is fine - that just means that its happily trying to get our list of todos from the server, but can't. No problemo, so that means we need to create a controller that will be our main AJAX endpoint.</p>

<pre><code>grails&gt; create-controller todo.TodosController
</code></pre>

<p>...which nicely maps to the aforementioned <em>/todos</em> thanks to Grails default conventions. Sweet! We'll also add an action to the controller that gives us a list of todo items. For now we'll just return an empty list in JSON. This is where Grails converters come really handy:</p>

<pre><code>package todo

import grails.converters.JSON 

class TodosController {

    def index() {
        render( [] as JSON )
    }
}
</code></pre>

<p>At this point our app is <em>nearly</em> working! We can see Backbone POSTing changes to our todos to the server. But nothing's being persisted yet, so if we refresh the page, our todo list is blank again. So, what we need in order to persist our data, is a domain class that mirrors the one that we have in our Todo backbone.js example:</p>

<pre><code>grails&gt; create-domain-class todo.Todo
</code></pre>

<p>In <em>grails-app/domain/todo/Todo.groovy</em>:</p>

<pre><code>package todo

class Todo {

    boolean done
    int order
    String text

    static constraints = {
        text(nullable: false, empty: false)
    }
}
</code></pre>

<p>And we'll also change our controller action to list all of our todo items:</p>

<pre><code>def index() {
    render( Todo.findAll() as JSON )
}
</code></pre>

<p>But so far we don't have any todos in the database, so the list is empty! Looking at AJAX traffic in Web Inspector, we see that whenever todos are updated, Backbone syncs them with the server via POSTs.</p>

<p><img src="/images/posts/web_inspector.png"></p>

<p>So, to create some nice RESTful URLs for our todo app, we'll just define them in <em>grails-app/conf/UrlMappings.groovy</em>:</p>

<pre><code>"/todos/$id?"(controller: "todos") {
    action = [GET:"list", POST: "save", DELETE: "delete", PUT: "edit"]
}
</code></pre>

<p>And a corresponding action to bind incoming POST data to a new todo item and save it:</p>

<pre><code>def save() {
    def todo = new Todo(request.JSON)
    render( todo.save() as JSON )
}
</code></pre>

<p>BAM! Our new todo items are persisted in MongoDB! Just like you guessed, DELETE is just as simple.</p>

<pre><code>def delete() {
    def todo = Todo.findById(params.id)
    todo?.delete()
    render(todo as JSON )
}
</code></pre>

<p>Now we can add and remove items. This is all nice and cool. However, what would a todo app be without a chance to complete some items? Backbone calls <em>.save()</em> on each update of a model item, and that translates to a PUT request to our backend. Based on our URL mappings, we'll still need to implement an <em>edit()</em> action:</p>

<pre><code>def edit() {
    def todo = Todo.findById(params.id)
    bindData(todo, request.JSON)
    render(todo.save() as JSON )                
}
</code></pre>

<p>And that's it! Our todo state now successfully propagates to the server! Job well done... oh wait! When we click on the checkboxes, nothing happens. And the original todo demo has a cool <em>"X tasks left"</em> that is not displayed in our application. What gives? Let's take a look at the Grails view template we use - bring up <em>index.gsp</em>:</p>

<pre><code>&lt;% if (total) { %&gt;
    &lt;span class="todo-count"&gt;
        &lt;span class="number"&gt;&lt;%= remaining %&gt;&lt;/span&gt;
        &lt;span class="word"&gt;&lt;%= remaining == 1 ? 'item' : 'items' %&gt;&lt;/span&gt; left.
    &lt;/span&gt;
&lt;% } %&gt;
&lt;% if (done) { %&gt;
    &lt;span class="todo-clear"&gt;
        &lt;a href="#"&gt;
            Clear &lt;span class="number-done"&gt;&lt;%= done %&gt;&lt;/span&gt;
            completed &lt;span class="word-done"&gt;&lt;%= done == 1 ? 'item' : 'items' %&gt;&lt;/span&gt;
        &lt;/a&gt;
    &lt;/span&gt;
&lt;% } %&gt;
</code></pre>

<p>A-ha! There's some underscore templates. But those look just like GSP scriptlets! And just as well, they don't show up in the generated markup. We need to fix those. Luckily there is a way to change how underscore interpolates the templates. Just put this at the top of <em>todos.js</em>:</p>

<pre><code>_.templateSettings = {
    interpolate : /\{\{(.+?)\}\}/g,
    evaluate : /\{!(.+?)!\}/g
};
</code></pre>

<p>And now we can change our templates to a nicer (nicer to .gsp that is) format. Just change all <em>&lt;%=</em> and <em>%></em> scriptlets to <em></em> respectively, and <em>&lt;%</em> and <em>%></em> to <em>{!</em> and <em>!}</em> and voila! A complete todo application! Albeit there's no authentication and multi-user and and and... Perhaps we'll add those later!</p>
]]></content>
  </entry>
  
</feed>
